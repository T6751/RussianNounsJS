/*!
  RussianNounsJS v1.2.0.SNAPSHOT

  Copyright (c) 2011-2021 Устинов Георгий Михайлович

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
!function(e, t) {
	"function" == typeof define && define.amd ? define([], t) : "object" == typeof module && module.exports ? module.exports = t() : e.RussianNouns = t();
}("undefined" != typeof self ? self : this, function() {
	"use strict";
	const e = Object.freeze({
		NOMINATIVE: "именительный",
		GENITIVE: "родительный",
		DATIVE: "дательный",
		ACCUSATIVE: "винительный",
		INSTRUMENTAL: "творительный",
		PREPOSITIONAL: "предложный",
		LOCATIVE: "местный"
	}), t = Object.freeze({
		FEMININE: "женский",
		MASCULINE: "мужской",
		NEUTER: "средний",
		COMMON: "общий"
	}), n = Object.freeze([ e.NOMINATIVE, e.GENITIVE, e.DATIVE, e.ACCUSATIVE, e.INSTRUMENTAL, e.PREPOSITIONAL, e.LOCATIVE ]), r = e => e.split("").map(e => String.fromCharCode(e.charCodeAt(0) + 1)).join(""), s = e => e.split(",").map(r).join(","), i = {
		Case: e,
		Gender: t,
		CASES: n,
		LemmaException: class extends Error {},
		StressDictionaryException: class extends Error {},
		Lemma: class {
			constructor(e) {
				function n(e) {
					if (null != e && "boolean" != typeof e) {
						throw new i.LemmaException("Must be boolean.");
					}
				}
				if (e instanceof i.Lemma) {
					this.pluraliaTantum = e.pluraliaTantum, this.indeclinable = e.indeclinable, this.animate = e.animate, 
					this.surname = e.surname, this.name = e.name, this.transport = e.transport, this.watercraft = e.watercraft, 
					this.internalText = e.internalText, this.lowerCaseText = e.lowerCaseText, this.internalGender = e.internalGender;
				} else {
					if (null == e) {
						throw new i.LemmaException("No parameters specified.");
					}
					if (n(e.pluraliaTantum), n(e.indeclinable), this.pluraliaTantum = !!e.pluraliaTantum, 
					this.indeclinable = !!e.indeclinable, n(e.animate), n(e.surname), n(e.name), n(e.transport), 
					n(e.watercraft), this.animate = !!e.animate, this.surname = !!e.surname, this.name = !!e.name, 
					this.transport = !!e.transport, this.watercraft = !!e.watercraft, null == e.text) {
						throw new i.LemmaException("A cyrillic word required.");
					}
					if (this.internalText = e.text, this.lowerCaseText = this.internalText.toLowerCase(), 
					!e.pluraliaTantum) {
						if (null == e.gender) {
							throw new i.LemmaException("A grammatical gender required.");
						}
						if (!Object.values(t).includes(e.gender)) {
							throw new i.LemmaException("Bad grammatical gender.");
						}
						this.internalGender = e.gender;
					}
				}
			}
			newText(e) {
				const t = new i.Lemma(this);
				return t.internalText = e(t), t.lowerCaseText = t.internalText.toLowerCase(), Object.freeze(t);
			}
			newGender(e) {
				const t = new i.Lemma(this);
				return t.internalGender = e(t), Object.freeze(t);
			}
			equals(e) {
				return e instanceof i.Lemma && this.lower() === e.lower() && this.isPluraliaTantum() === e.isPluraliaTantum() && (this.isPluraliaTantum() || this.getGender() === e.getGender()) && this.isIndeclinable() === e.isIndeclinable() && this.isAnimate() === e.isAnimate() && this.isASurname() === e.isASurname() && this.isAName() === e.isAName() && this.isATransport() === e.isATransport() && this.isAWatercraft() === e.isAWatercraft();
			}
			fuzzyEquals(e) {
				return e instanceof i.Lemma && m(this.lower()) === m(e.lower()) && this.isPluraliaTantum() === e.isPluraliaTantum() && (this.isPluraliaTantum() || this.getGender() === e.getGender()) && this.isIndeclinable() === e.isIndeclinable();
			}
			text() {
				return this.internalText;
			}
			lower() {
				return this.lowerCaseText;
			}
			isPluraliaTantum() {
				return this.pluraliaTantum;
			}
			getGender() {
				return this.internalGender;
			}
			isIndeclinable() {
				return this.indeclinable;
			}
			isAnimate() {
				return this.animate || this.surname || this.name;
			}
			isASurname() {
				return this.surname;
			}
			isAName() {
				return this.name;
			}
			isATransport() {
				return this.transport || this.watercraft;
			}
			isAWatercraft() {
				return this.watercraft;
			}
		},
		createLemma: e => e instanceof i.Lemma ? e : Object.freeze(new i.Lemma(e)),
		getDeclension: e => g(i.createLemma(e)),
		getSchoolDeclension: e => {
			const t = g(i.createLemma(e));
			return 1 === t ? 2 : 2 === t ? 1 : t;
		},
		FIXED_STEM_STRESS: "SSSSSSS-SSSSSS",
		FIXED_ENDING_STRESS: "EEEEEEE-EEEEEE",
		StressDictionary: class {
			constructor() {
				this.data = {};
			}
			put(e, t) {
				if (!t.match(/^[SsbeE]{7}-[SsbeE]{6}$/)) {
					throw new i.StressDictionaryException("Bad settings format.");
				}
				const n = i.createLemma(e), r = m(n.lower());
				let s = this.data[r];
				s instanceof Array || (s = [], this.data[r] = s);
				const u = s.find(e => n.equals(e[0]));
				u ? u[1] = t : s.push([ n, t ]);
			}
			get(e, t) {
				const n = i.createLemma(e), r = m(n.lower()), s = this.data[r];
				if (s instanceof Array) {
					let e = s.find(e => n.equals(e[0]));
					if (!e && t && (e = s.find(e => n.fuzzyEquals(e[0]))), e) {
						return e[1];
					}
				}
			}
			remove(e) {
				const t = i.createLemma(e), n = m(t.lower()), r = this.data[n];
				r instanceof Array && (this.data[n] = r.filter(e => !t.equals(e[0])), 0 === this.data[n].length && delete this.data[n]);
			}
			hasStressedEndingSingular(e, t) {
				const r = n.indexOf(t);
				if (r >= 0) {
					const t = this.get(e, !0);
					if (t) {
						const e = t.split("-")[0];
						return "E" === e[r] ? [ !0 ] : "e" === e[r] ? [ !0, !1 ] : "b" === e[r] ? [ !1, !0 ] : "s" === e[r] ? [ !1, !0 ] : [ !1 ];
					}
				}
				return [];
			}
			hasStressedEndingPlural(e, t) {
				const r = n.indexOf(t);
				if (r >= 0 && r < 6) {
					const t = this.get(e, !0);
					if (t) {
						const e = t.split("-")[1];
						return "E" === e[r] ? [ !0 ] : "e" === e[r] ? [ !0, !1 ] : "b" === e[r] ? [ !1, !0 ] : "s" === e[r] ? [ !1, !0 ] : [ !1 ];
					}
				}
				return [];
			}
			find(e) {
				const t = m(e).toLowerCase(), n = this.data[t];
				return n instanceof Array ? n.map(e => e[0]) : [];
			}
		},
		Engine: class {
			constructor() {
				this.sd = function() {
					const e = new i.StressDictionary();
					function n(t, n, r) {
						const s = r.split(",");
						for (let r of s) {
							const s = Object.assign({}, t);
							s.text = r, e.put(s, n);
						}
					}
					function r(n, r) {
						e.put({
							text: r,
							gender: t.MASCULINE
						}, n);
					}
					n({
						gender: t.MASCULINE
					}, i.FIXED_STEM_STRESS, "брёх,дёрн,идиш,имидж,мед"), n({
						gender: t.MASCULINE
					}, "SSSSSSS-EEEEEE", "адрес,век,вечер,город,детдом,поезд"), n({
						gender: t.MASCULINE
					}, "SSSSSSE-EEEEEE", "берег,бок,вес,лес,снег,дом,катер,счёт,мёд"), n({
						gender: t.MASCULINE,
						animate: !0
					}, i.FIXED_STEM_STRESS, "балансёр,шофёр"), n({
						gender: t.MASCULINE
					}, "SSSSSSS-bbbbbb", "вексель,ветер"), r("SSSSSSE-ESEEEE", "глаз"), r("SSSSSSE-bEEbEE", "год"), 
					r("SSSSSSb-bbbbbb", "цех"), r("SSSSSSE-EEEEEE", "счёт"), n({
						gender: t.NEUTER
					}, "EEEEEEE-SSSSSS", "тесло,стекло,автостекло,бронестекло,оргстекло,пеностекло,смарт-стекло,спецстекло,бедро,берцо,блесна,чело,стегно,стебло"), 
					e.put({
						text: "щека",
						gender: t.FEMININE,
						animate: !1
					}, "EEEbEEE-SSESEE"), n({
						gender: t.MASCULINE
					}, "SbbSbbb-bbbbbb", "грош,шприц"), n({
						gender: t.MASCULINE
					}, "SssSsss-ssssss", "кишмиш,кряж,слеш,слэш"), n({
						gender: t.MASCULINE,
						animate: !0
					}, "Sssssss-ssssss", "паныч"), r("SEESeEE-EEEEEE", "стеллаж"), r("SeeSeee-eeeeee", "шиномонтаж"), 
					n({
						gender: t.MASCULINE
					}, "SEESEEE-EEEEEE", "багаж,грузобагаж,товаробагаж,багрец,барыш,беляш,бердыш,бич,бандаж,блиндаж,бубенец,буж,валец,варенец,венец,вираж,витраж,волосенец,волчец,вольтаж,воронец,галдёж,гамма-луч,гнилец,гараж,автогараж,голец,головач,голыш,горбач,горлач,голубец,грабёж,гуж,гуляш,дворец,делёж,дергач,долбёж,долгунец,драч,ёрш,зубец,зубрёж,изразец,калач,ключ,камыш,карандаш,картёж,кедрач,кирпич,клинец,ковш,корец,козелец,конец,кострец,копач,крепёж,крестец,круглыш,кругляш,крыж,крылач,кулеш,кулич,кумач,контуш,кунтуш,купаж,кураж,кутёж,леденец,листаж,литраж,луч,метраж,меч,мираж,монтаж,муляж,мятеж,мокрец,москвич,неплатёж,нож,нутрец,овсец,огурец,орлец,острец,падеж,падёж,паж,палаш,паралич,первач,пернач,песец," + s("озжгдх,фтдх,") + "пихтач,платёж,погребец,подэтаж,поставец,поташ,правёж,путец,пыж,пугач,резец,ржанец,рубеж,рубец,рогач,свербёж,светец,сенаж,скулёж,слопец,сныч,солонец,сосец,свинец,тетраэтилсвинец,секач,спорыш,столбец,строгач,сургуч,сутаж,сыпец,сырец,сыровец,терпёж,типаж,тираж,толкач,торец,тягач,тяж,типец,тирлич,тупец,тупыш,целкач,чабрец,чепец,фураж,хвостец,хлопунец,холодец,чертёж,чистец,шалаш,шантаж,шиш,щипец,электронож,этаж,ясенец"), 
					n({
						gender: t.MASCULINE,
						animate: !0
					}, "SEEEEEE-EEEEEE", "алкаш,басмач,беглец,белец,бирюч,бич,близнец,бомж,богач,боец,борец,бородач,брюхач,вдовец,волосач,врач,главврач,ветврач,военврач,диетврач,санврач,глупец,глупыш,голец,головач,голыш,гонец,горбач,гордец,грач,гребец,делец,дергач,донец,дохлец,драч,ёж,ёрш,елец,жеребец,живец,жилец,жнец,жрец,избач,ингуш,камыш,корж,морж,кольчец,копач,кормач,коротыш,косач,косец,космач,крепыш,кряж,кудряш,кузнец,купец,латыш,легаш,лжец,лихач,ловец,ловкач,лохмач,малец,малыш,мертвец,мигач,мордаш,мокрец,москвич,мудрец,мураш,носач,оголец,омич,отец,праотец,паж,камер-паж,палач,пантач,певец,песец,писец,плавунец,подлец,племяш,пловец,портач,продавец,перепродавец,пошлец,пришлец,простец,птенец,пузач,пугач,рвач,рифмач,рогач,рунец,рыбец,ремнец,самец,сарыч,севец,силач,синец,скворец,скопец,скрипач,скупец,секач,слепец,слепыш,слухач,смехач,сморкач,снохач,соистец,сорванец,спец,военспец,стервец,стрелец,стригунец,стриж,стукач,сыч,стрекач,струнец,творец,телец,ткач,толмач,торгаш,трубач,трюкач,тунец,трепач,трепец,тупец,тупыш,тяглец,удалец,уж,усач,хитрец,хохмач,храбрец,хромец,хрыч," + s("фЯц,") + "циркач,червец,чернец,черныш,швец,шельмец,чтец,чиж,юнец"), 
					e.put({
						text: "судья",
						gender: t.COMMON,
						animate: !0
					}, "EEEEEEE-SSSSSS");
					for (let n of [ "семья", "макросемья" ]) {
						e.put({
							text: n,
							gender: t.FEMININE
						}, "EEEEEEE-SESSSS");
					}
					e.put({
						text: "свинья",
						gender: t.FEMININE,
						animate: !0
					}, "EEEEEEE-SESESS"), e.put({
						text: "скамья",
						gender: t.FEMININE
					}, "EEEEEEE-eEeeee");
					for (let n of [ "ладья", "статья" ]) {
						e.put({
							text: n,
							gender: t.FEMININE
						}, i.FIXED_ENDING_STRESS);
					}
					return e;
				}();
			}
			decline(n, r, u) {
				return function(n, i, u, c) {
					const E = function(n, r, i, u) {
						const c = r.text();
						if (r.isIndeclinable()) {
							return c;
						}
						if (r.isPluraliaTantum()) {
							return P(n, r, i, c);
						}
						if (u) {
							return P(n, r, i, u);
						}
						switch (g(r)) {
						  case -1:
							return c;

						  case 0:
							return x(n, r, i);

						  case 1:
							return function n(r, i, u) {
								const c = i.text(), E = i.lower(), S = i.getGender(), I = function(e) {
									if (e.startsWith("пол") && [ "и", "ы", "а", "я", "ь" ].includes(d(e)) && o(e) >= 2) {
										let t = e.substring(3), n = t.search(/[а-яА-ЯёЁ]/);
										return n >= 0 && a.includes(t[n].toLowerCase());
									}
									return !1;
								}(E);
								if (I && p(E, [ "и", "ы" ])) {
									if ([ e.NOMINATIVE, e.ACCUSATIVE ].includes(u)) {
										return c;
									}
									{
										const t = e => [ "полминуты" ].includes(e.lower()) ? e.text() : "полу" + e.text().substring(3);
										if ("полпути" === E) {
											if ([ e.PREPOSITIONAL, e.LOCATIVE ].includes(u)) {
												return c;
											}
											{
												let e = i.newText(e => f(t(e)) + "ь");
												return x(r, e, u);
											}
										}
										if (E.endsWith("зни")) {
											let e = i.newText(e => f(t(e)) + "ь");
											return U(r, e, u);
										}
										{
											let e = i.newText(e => f(t(e)) + ("н" === d(e.lower()) ? "я" : "а"));
											return W(r, e, u);
										}
									}
								}
								let A = w(i), T = f(c);
								const N = I && E.endsWith("я") || M(E);
								I && (A = "полу" + A.substring(3), T = "полу" + T.substring(3));
								let L = A.toLowerCase();
								const g = (e, t) => {
									const n = r.sd.hasStressedEndingSingular(i, u);
									return n.length || n.push(!1), n.map(n => t(n ? m(e) : e, n));
								}, V = () => "й" === d(E) || [ "ий", "ие", "иё" ].includes(h(E, 2)), P = () => (() => p(E, [ "воробей", "муравей", "ручей", "соловей", "улей" ]))() ? f(T) + l("ь", d(T)) : T, R = () => "чщ".includes(d(L)), y = () => "ый" === h(E, 2) || E.endsWith("ной") && o(c) >= 2;
								if (e.NOMINATIVE === u) {
									return c;
								}
								if (e.GENITIVE === u) {
									const e = e => (!i.isAnimate() && "клей,чай,дом,дух,дым,дымок,газ,год,горошек,жар,жир,квас,пар,пыл,род,рост,сахар,свет,сироп,смех,снег,снежок,сок,сор,спор,срок,соус,спирт,страх,суп,сыр,табак,творог,толк,торф,туман,убыток,укроп,уксус,ход,цемент,чеснок,шаг,шик,шиповник,шоколад,шорох,шум,яд".split(",").includes(E) && ("й" === d(E) ? e.push(f(c) + l("ю", d(c))) : e = e.concat(g(A, e => e + l("у", d(e))))), 
									e);
									if (V() && i.isASurname() || y() || p(E, [ "ое", "нький", "ский", "евой", "овой" ])) {
										return A + "ого";
									}
									if (p(E, [ "ее", "кожий", "шний", "жний", "щий", "ший", "чий" ])) {
										return A + "его";
									}
									if (V()) {
										return e([ P() + "я" ]);
									}
									if (N && !R()) {
										return A + "я";
									}
									if (C(E)) {
										return O(c, i) + "ца";
									}
									if (b(E)) {
										return f(T) + "ка";
									}
									{
										let t = [];
										return i.isASurname() || -1 === L.indexOf("ё") ? t.push(A + "а") : t = t.concat(g(A, e => e + "а")), 
										e(t);
									}
								}
								if (e.DATIVE === u) {
									return V() && i.isASurname() || y() || p(E, [ "ое", "нький", "ский", "евой", "овой" ]) ? A + "ому" : p(E, [ "ее", "кожий", "шний", "жний", "щий", "ший", "чий" ]) ? A + "ему" : V() ? P() + "ю" : N && !R() ? A + "ю" : C(E) ? O(c, i) + "цу" : b(E) ? f(T) + "ку" : i.isASurname() || -1 === L.indexOf("ё") ? A + "у" : g(A, e => e + "у");
								}
								if (e.ACCUSATIVE === u) {
									if (S === t.NEUTER) {
										return c;
									}
									return !0 === i.isAnimate() ? n(r, i, e.GENITIVE) : c;
								}
								if (e.INSTRUMENTAL === u) {
									return V() && i.isASurname() || p(E, [ "ое", "ее", "нький", "ский" ]) ? "целое" !== E ? A + "им" : A + "ым" : y() || p(E, [ "евой", "овой" ]) ? A + "ым" : p(E, [ "кожий", "шний", "жний", "щий", "ший", "чий" ]) ? f(T) + "им" : V() ? P() + "ем" : N || "жчш".includes(d(L)) ? g(A, (e, t) => t ? e + "ом" : e + "ем") : C(E) ? g(c, (e, t) => t ? O(e, i) + "цом" : O(e, i) + "цем") : E.endsWith("це") ? c + "м" : b(E) ? f(T) + "ком" : (() => i.isASurname() && (E.endsWith("ын") || E.endsWith("ин") || E.endsWith("ов") || E.endsWith("ев") || E.endsWith("ёв")))() ? c + "ым" : i.isASurname() || -1 === L.indexOf("ё") ? A + "ом" : g(A, e => e + "ом");
								}
								if (e.PREPOSITIONAL === u) {
									if (V() && i.isASurname() || y() || p(E, [ "ое", "нький", "ский", "евой", "овой" ])) {
										return A + "ом";
									}
									if (p(E, [ "ее", "кожий", "шний", "жний", "щий", "ший", "чий" ])) {
										return A + "ем";
									}
									if (p(E, [ "воробей" ])) {
										const e = f(T);
										return e + l("ье", d(e));
									}
									return p(E, [ "ий", "ие", "чье", "тье", "дье", "вье", "бье", "енье", "жалованье", "ружье", "божье", "верье", "мужье" ]) && !p(E, [ "запястье", "здоровье", "изголовье" ]) ? T + "и" : "й" === d(E) || "иё" === h(E, 2) ? P() + "е" : C(E) ? O(c, i) + "це" : b(E) ? f(T) + "ке" : i.isASurname() || -1 === L.indexOf("ё") ? A + "е" : g(A, e => e + "е");
								}
								if (e.LOCATIVE === u) {
									const t = ("ад,баз,бал,бег,берег,бережок,бой,бок,бочок,бор,борт,бред,быт,век,верх,вес,ветер,ветр,вид,воз,газ,глаз,год,горб,гроб,день,долг,дух,дым,жир,зад,клей,кол,кон,корень,край,круг,лад,лёд,лед,лоб,мох,угол,лес,луг,мёд,мел,мех,мозг,низ,нос,плен,пол,полк,артполк,порт,аэропорт,пух,рай,род,сад,свет,слух,снег,сок,спирт,строй,счёт,счет,сук," + s("фти,") + "тыл,ход,час,шаг,шкаф,яр").split(","), u = "вор".split(",");
									return t.includes(E) && !i.isAnimate() || u.includes(E) ? "й" === d(E) ? m(T) + "ю" : N ? m(A) + "ю" : b(E) ? m(f(T)) + "ку" : m(A) + "у" : n(r, i, e.PREPOSITIONAL);
								}
							}(n, r, i);

						  case 2:
							return W(n, r, i);

						  case 3:
							return U(n, r, i);
						}
					}(n, i, r, c);
					return E instanceof Array ? E : [ E ];
				}(this, i.createLemma(n), 0, u);
			}
			pluralize(n) {
				const r = i.createLemma(n);
				return r.isPluraliaTantum() ? [ r.text() ] : function(n, r) {
					const s = [], i = r.text(), u = r.lower(), a = w(r), c = a.toLowerCase(), L = n.sd.hasStressedEndingPlural(r, e.NOMINATIVE);
					Object.freeze(L);
					const x = t => {
						const s = n.sd.hasStressedEndingPlural(r, e.NOMINATIVE).map(e => !e);
						return s.length ? s.map(e => e ? N(c) ? t(T(a)) : t(a) : t(m(a))) : [ t(a) ];
					}, W = (e, t) => {
						const n = L.slice();
						return n.length || n.push(!1), n.map(n => t(n ? m(e) : e));
					}, U = r.getGender(), P = g(r), R = ("й" == d(u) || E(d(i))) && E(d(f(i))) ? f(i) : a, y = () => (u.endsWith("евич") || u.endsWith("евна")) && u.indexOf("ье") >= 0;
					function G() {
						const e = R, t = e.toLowerCase().indexOf("ье"), n = l("и", e[t]);
						return e.substring(0, t) + n + e.substring(t + 1);
					}
					function D(e) {
						"гжкхчшщ".includes(d(c)) || "яйь".includes(d(u)) || p(u, [ "сосед" ]) ? y() ? (s.push(G() + "и"), 
						s.push(R + "и")) : s.push(R + "и") : C(u) ? s.push(O(i, r) + "цы") : y() ? (s.push(G() + "ы"), 
						s.push(R + "ы")) : e ? s.push(R + "ы") : Array.prototype.push.apply(s, W(R, e => e + "ы"));
					}
					const j = [ [ [ t.MASCULINE, void 0 ], {
						"болгарин": [ "болгары" ],
						"господин": [ "господа" ],
						"дядя": [ "дяди", "дядья" ],
						"зуб": [ "зубы", "зубья" ],
						"инок": [ "иноки" ],
						"исток": [ "истоки" ],
						"клок": [ "клочья", "клоки" ],
						"князь": [ "князи", "князья" ],
						"кол": [ "колы", "колья" ],
						"месяц": [ "месяцы" ],
						"татарин": [ "татары" ],
						"хозяин": [ "хозяева" ],
						"цветок": [ "цветки", "цветы" ]
					} ], [ [ t.MASCULINE, !0 ], {
						"кондуктор": [ "кондуктора", "кондукторы" ],
						"кум": [ "кумовья" ],
						"муж": [ "мужья", "мужи" ]
					} ], [ [ t.FEMININE, void 0 ], {
						"вошь": [ "вши" ],
						"гроздь": [ "грозди", "гроздья" ],
						"курица": [ "курицы", "куры" ],
						"береста": [ "берёсты" ],
						"верста": [ "вёрсты" ],
						"десна": [ "дёсны" ],
						"жена": [ "жёны" ],
						"звезда": [ "звёзды" ],
						"кинозвезда": [ "кинозвёзды" ],
						"стая": [ "стаи" ],
						"щека": [ "щёки" ]
					} ], [ [ t.NEUTER, void 0 ], {
						"брюхо": [ "брюхи" ],
						"колено": [ "колена", "колени", "коленья" ],
						"древо": [ "древа", "древеса" ],
						"ухо": [ "уши" ],
						"око": [ "очи" ],
						"дно": [ "донья" ],
						"чудо": [ "чудеса", "чуда" ],
						"небо": [ "небеса" ],
						"бревно": [ "брёвна" ],
						"ведро": [ "вёдра" ],
						"веретено": [ "веретёна" ],
						"весло": [ "вёсла" ],
						"гнездо": [ "гнёзда" ],
						"зерно": [ "зёрна" ],
						"знамя": [ "знамёна" ],
						"колесо": [ "колёса" ]
					} ] ];
					for (const [e, t] of j) {
						const n = e[0], i = e[1];
						if (U === n && (null == i || i === r.isAnimate()) && t.hasOwnProperty(u)) {
							const e = t[u];
							for (let t of e) {
								s.push(t);
							}
							return A(s);
						}
					}
					const F = [ "зять", "деверь", "друг", "брат", "собрат", "лист", "стул", "брус", "обод", "полоз", "струп", "подмастерье", "якорь", "перо", "шило" ], z = "ь" === d(c) ? a : "к" === d(c) ? f(a) + "чь" : "г" === d(c) ? f(a) + "зь" : "й" === d(u) ? f(i) : p(u, [ "рь", "ль" ]) ? a : a + "ь";
					switch (P) {
					  case -1:
						s.push(i);
						break;

					  case 0:
						if ("путь" === u) {
							s.push("пути");
						} else {
							if (!u.endsWith("дитя")) {
								throw new Error("unsupported");
							}
							s.push(S(i, 3) + "ети");
						}
						break;

					  case 1:
						if (F.includes(u)) {
							s.push(z + "я");
						} else if (t.MASCULINE === U) {
							const e = [ "берег", "бок", "борт", "век", "вес", "веер", "вексель", "вечер", "глаз", "голос", "город", "доктор", "дом", "детдом", "егерь", "жемчуг", "катер", "колокол", "концлагерь", "корм", "короб", "кузов", "купол", "лес", "мастер", "номер", "сахар", "снег", "сорт", "счет", "счёт", "терем", "том", "холод", "цвет", "череп" ], t = [ "округ", "остров", "отпуск", "поезд", "цех", "юнкер" ], n = [ "адрес", "договор", "буфер", "ворох", "год", "директор", "инспектор", "инструктор", "корпус", "крейсер", "орден", "ордер", "тенор", "тон", "трактор", "тормоз", "ветер", "верх", "китель", "мех", "юнкер", "ястреб" ], c = [ "бункер", "вымпел", "образ", "омут", "токарь", "тополь", "шторм", "штуцер" ], E = [ "лоскут", "повод", "прут", "сук", "учитель", "флигель", "штабель" ], l = [ "клин", "колос", "ком", "край" ];
							"сын" === u ? (s.push("сыновья"), D()) : "человек" === u ? (s.push("люди"), D()) : E.includes(u) ? (D(), 
							s.push(z + "я")) : l.includes(u) ? s.push(z + "я") : e.includes(u) || p(u, t) || n.includes(u) || c.includes(u) ? (c.includes(u) && D(), 
							M(u) ? Array.prototype.push.apply(s, x(e => e + "я")) : L.includes(!0) ? s.push(m(a) + "а") : s.push(a + "а"), 
							n.includes(u) && D()) : (u.endsWith("анин") || u.endsWith("янин")) && !r.isAName() || [ "барин", "боярин" ].includes(u) ? (s.push(S(i, 2) + "е"), 
							"барин" === u && s.push(S(i, 2) + "ы")) : [ "цыган" ].includes(u) ? s.push(i + "е") : "щенок" == u ? (s.push(S(i, 2) + "ки"), 
							s.push(S(i, 2) + "ята")) : !u.endsWith("ёнок") && !u.endsWith("енок") || p(u, [ "коленок", "стенок", "венок", "ценок", "валенок", "оттенок", "черенок" ]) ? u.endsWith("ёночек") ? s.push(S(i, 6) + "ятки") : u.endsWith("онок") && "жчш".includes(I(u, 4)) && !u.endsWith("бочонок") ? s.push(S(i, 4) + "ата") : b(u) ? s.push(S(i, 2) + "ки") : u.endsWith("ый") || p(u, [ "щий", "чий", "жний", "шний", "ский" ]) ? s.push(f(i) + "е") : u.endsWith("вой") && o(S(i, 3)) >= 2 || p(u, [ "ной", "мой" ]) && i.length >= 6 ? s.push(S(i, 2) + "ые") : p(u, [ "хой", "ший" ]) ? s.push(S(i, 2) + "ие") : u.endsWith("его") ? s.push(S(i, 3) + "ие") : [ "воробей", "муравей", "ручей", "соловей", "улей", "жеребей", "ирей", "репей", "чирей" ].includes(u) ? s.push(S(i, 2) + "ьи") : D() : s.push(S(i, 4) + "ята");
						} else if (t.NEUTER === U) {
							if (p(u, [ "ко", "чо" ]) && !p(u, [ "войско", "облако" ])) {
								s.push(f(i) + "и");
							} else if (u.endsWith("имое")) {
								s.push(a + "ые");
							} else if (u.endsWith("ее")) {
								s.push(a + "ие");
							} else if (u.endsWith("ое")) {
								p(c, [ "г", "к", "ж", "ш" ]) ? s.push(a + "ие") : s.push(a + "ые");
							} else if (p(u, [ "ие", "иё" ])) {
								s.push(S(i, 2) + "ия");
							} else if (p(u, [ "ье", "ьё" ])) {
								const e = S(i, 2), t = [ "безделье", "варенье", "воскресенье", "жалованье", "запястье", "застолье", "затишье", "здоровье", "зелье", "изголовье", "новоселье", "одночасье", "печенье", "платье", "побережье", "поголовье", "подворье", "подземелье", "подполье", "поместье", "предплечье", "раздумье", "сиденье", "средневековье", "увечье", "угодье", "устье" ].includes(u);
								"е" !== d(u) || t || s.push(e + "ия"), s.push(e + "ья");
							} else {
								p(u, [ "дерево", "звено", "крыло" ]) ? s.push(a + "ья") : p(u, [ "ле", "ре" ]) ? s.push(a + "я") : "судно" === u && r.isATransport() ? (s.push("суда"), 
								r.isAWatercraft() || s.push("судна")) : (Array.prototype.push.apply(s, x(e => e + "а")), 
								p(u, [ "щупальце" ]) && D());
							}
						} else {
							s.push(a + "и");
						}
						break;

					  case 2:
						"заря" === u ? s.push("зори") : u.endsWith("ая") ? "жш".includes(d(c)) || p(c, [ "ск", "цк" ]) ? s.push(a + "ие") : s.push(a + "ые") : D();
						break;

					  case 3:
						"мя" === h(u, 2) ? s.push(a + "ена") : Object.keys(V).includes(u) ? s.push(f(V[u]) + "и") : t.FEMININE === U ? s.push(R + "и") : "и" === d(R) ? s.push(R + "я") : s.push(R + "а");
					}
					return A(s);
				}(this, r);
			}
		}
	}, u = "бвгджзклмнпрстфхцчшщ", a = u + "й", c = "аоуэыяёюеи", E = e => c.includes(e.toLowerCase()), l = (e, t) => (e => e === e.toUpperCase())(t) ? e.toUpperCase() : e, o = e => e.split("").filter(E).length, d = e => e && e.length ? e[e.length - 1] : "", h = (e, t) => e.substring(e.length - t), f = e => e.substring(0, e.length - 1), S = (e, t) => e.substring(0, e.length - t), I = (e, t) => d(S(e, t)), p = (e, t) => t.filter(t => e.endsWith(t)).length > 0, A = e => e.filter((t, n) => e.indexOf(t) === n), m = e => e.replace("ё", "е").replace("Ё", "Е"), T = e => {
		const t = Math.max(e.toLowerCase().lastIndexOf("е"), e.toLowerCase().lastIndexOf("ё")), n = l("ё", e[t]);
		return e.substring(0, t) + n + e.substring(t + 1);
	}, N = e => 1 === e.replace(/[^её]/g, "").length;
	function L(e) {
		const t = d(e).toLowerCase();
		return ("й" === t || E(t)) && E(d(f(e))) ? S(e, 2) : E(t) ? f(e) : e;
	}
	function w(e) {
		const n = e.text(), r = e.lower(), s = e.getGender(), i = d(r);
		if ([ "бубен", "бугор", "ветер", "вымысел", "горшок", "дятел", "домысел", "замысел", "кашель", "коготь", "лапоть", "лоб", "локоть", "ломоть", "молебен", "мох", "ноготь", "овен", "пепел", "пес", "пёс", "петушок", "помысел", "порошок", "посол", "промысел", "псалом", "пушок", "ров", "рот", "сон", "стебель", "стишок", "угол", "умысел", "хребет", "церковь", "шов" ].includes(r) || p(r, [ "узел", "уголь", "чок", "ешок", "хол" ])) {
			const e = "ь" === i ? f(n) : n;
			return S(e, 2) + d(e);
		}
		if ([ "лёд", "лед" ].includes(r) || "лев" === r && e.isAnimate()) {
			return S(n, 2) + l("ь", d(f(n))) + d(n);
		}
		if (r.endsWith("рёк") && o(n) >= 2) {
			return S(n, 2) + "ьк";
		}
		if (r.endsWith("ёк") && E(I(n, 2))) {
			return S(n, 2) + "йк";
		}
		if (u.includes(d(r))) {
			return n;
		}
		if ("ь" === d(r)) {
			const e = [ "ясень", "бюллетень", "олень", "гордень", "пельмень", "ячмень" ];
			return r.endsWith("ень") && s === t.MASCULINE && !p(r, e) ? S(n, 3) + "н" : f(n);
		}
		return "ь" === d(f(r)) ? f(n) : "о" === d(r) && "влмнстх".includes(d(f(r))) ? f(n) : L(n);
	}
	function g(e) {
		const n = e.lower(), r = e.getGender();
		if (e.isPluraliaTantum()) {
			return;
		}
		if (e.isIndeclinable()) {
			return -1;
		}
		const s = d(n);
		switch (r) {
		  case t.FEMININE:
			return "а" == s || "я" == s ? 2 : a.includes(s) ? -1 : 3;

		  case t.MASCULINE:
			return "а" == s || "я" == s ? 2 : "путь" == n ? 0 : 1;

		  case t.NEUTER:
			return [ "дитя", "полудитя" ].includes(n) ? 0 : "мя" == h(n, 2) ? 3 : 1;

		  case t.COMMON:
			return "а" === s || "я" === s ? 2 : "и" === s ? -1 : 1;

		  default:
			throw new Error("incorrect gender");
		}
	}
	const C = e => "ц" === d(e);
	function O(e, t) {
		const n = f(e), r = f(t.lower());
		if ("а" === d(r)) {
			return n;
		}
		if (p(r, [ "зне", "жне", "гре", "спе", "мудре" ]) || h(f(r), 3).split("").every(e => u.includes(e)) || t.isAName()) {
			return n;
		}
		if ("ле" === h(r, 2)) {
			const e = I(r, 2);
			return E(e) || "л" === e ? f(n) + "ь" : n;
		}
		return E(d(r)) && "и" !== d(r) ? E(d(f(r))) ? S(e, 2) + "й" : S(e, 2) : n;
	}
	function b(e) {
		return p(e, [ "чек", "шек" ]) && e.length >= 6 || p(e, [ "лапоток", "желток" ]) || e.endsWith("ок") && !e.endsWith("шок") && ![ "инок", "обморок", "порок", "пророк", "сток", "урок" ].includes(e) && !p(e, [ "поток", "приток", "переток", "проток", "биоток", "электроток", "восток", "водосток", "водоток", "воток", "знаток" ]) && !E(I(e, 2)) && (E(I(e, 3)) || p(S(e, 2), [ "ст", "рт" ])) && e.length >= 4;
	}
	const M = e => "ь" === d(e) && !e.endsWith("господь") || "её".includes(d(e)) && !p(e, [ "це", "же" ]);
	function x(t, n, r) {
		const s = n.text(), i = n.lower();
		if (i.endsWith("путь")) {
			return r === e.INSTRUMENTAL ? f(s) + "ём" : U(t, n, r);
		}
		if (!i.endsWith("дитя")) {
			throw new Error("unsupported");
		}
		switch (r) {
		  case e.NOMINATIVE:
		  case e.ACCUSATIVE:
			return s;

		  case e.GENITIVE:
		  case e.DATIVE:
		  case e.PREPOSITIONAL:
		  case e.LOCATIVE:
			return s + "ти";

		  case e.INSTRUMENTAL:
			return [ s + "тей", s + "тею" ];
		}
	}
	function W(t, n, r) {
		const s = n.text(), i = n.lower(), u = w(n), a = u.toLowerCase(), c = f(s), l = f(i), S = () => "я" === d(i), I = () => i.endsWith("ая") && !(2 === o(s) || E(d(u)));
		switch (r) {
		  case e.NOMINATIVE:
			return s;

		  case e.GENITIVE:
			return I() ? u + "ой" : n.isASurname() ? c + "ой" : S() || "гжкхчшщ".includes(d(a)) ? c + "и" : c + "ы";

		  case e.DATIVE:
			return I() ? u + "ой" : n.isASurname() ? c + "ой" : "ия" === h(i, 2) ? c + "и" : c + "е";

		  case e.ACCUSATIVE:
			return I() ? u + "ую" : S() ? c + "ю" : c + "у";

		  case e.INSTRUMENTAL:
			return I() ? u + "ой" : S() || "жцчшщ".includes(d(a)) ? "и" === d(l) ? c + "ей" : [ c + "ей", c + "ею" ] : [ c + "ой", c + "ою" ];

		  case e.PREPOSITIONAL:
			return I() ? u + "ой" : n.isASurname() ? c + "ой" : "ия" === h(i, 2) ? c + "и" : c + "е";

		  case e.LOCATIVE:
			return W(t, n, e.PREPOSITIONAL);
		}
	}
	const V = {
		"дочь": "дочерь",
		"мать": "матерь"
	};
	function U(t, n, r) {
		const s = n.text(), i = n.lower();
		if (![ e.NOMINATIVE, e.ACCUSATIVE ].includes(r) && Object.keys(V).includes(i)) {
			return U(t, n.newText(() => V[i]), r);
		}
		const u = w(n);
		if ("мя" === h(i, 2)) {
			switch (r) {
			  case e.NOMINATIVE:
				return s;

			  case e.GENITIVE:
			  case e.DATIVE:
				return u + "ени";

			  case e.ACCUSATIVE:
				return s;

			  case e.INSTRUMENTAL:
				return u + "енем";

			  case e.PREPOSITIONAL:
				return u + "ени";

			  case e.LOCATIVE:
				return U(t, n, e.PREPOSITIONAL);
			}
		} else {
			switch (r) {
			  case e.NOMINATIVE:
				return s;

			  case e.GENITIVE:
			  case e.DATIVE:
				return u + "и";

			  case e.ACCUSATIVE:
				return s;

			  case e.INSTRUMENTAL:
				return "церковь" === i ? s + "ю" : u + "ью";

			  case e.PREPOSITIONAL:
				return u + "и";

			  case e.LOCATIVE:
				return U(t, n, e.PREPOSITIONAL);
			}
		}
	}
	function P(n, s, i, a) {
		const o = a.toLowerCase(), h = s.getGender(), A = o.endsWith("цы") ? f(a) : L(a), T = [ "ли", "си", "ви", "ди", "ти", "пи", "ри", "ни", "фи", "зи", "ьи", "ья", "ия", "ря", "ля", "ая" ];
		for (let e of c) {
			T.push(e + "и");
		}
		const N = () => o.endsWith("ые"), w = () => o.endsWith("ие"), C = e => n.sd.hasStressedEndingPlural(s, i).includes(!0) ? m(e) : e, O = [ "головы", "громадины", "детины", "деревенщины", "дохлятины", "дубины", "ехидины", "жадины", "зверины", "идиотины", "кислятины", "молодчины", "орясины", "остолопины", "сиротины", "скотины", "старейшины", "старины", "старшины", "уродины" ], b = () => p(o, [ "овы", "евы", "ёвы", "ины", "ыны" ]) && !p(o, O) && (s.isASurname() || h === t.COMMON);
		if (e.DATIVE === i) {
			return b() ? a + "м" : N() ? S(a, 2) + "ым" : w() ? S(a, 2) + "им" : p(o, T) ? f(a) + "ям" : C(A) + "ам";
		}
		if (e.INSTRUMENTAL === i) {
			return b() ? a + "ми" : N() ? S(a, 2) + "ыми" : w() ? S(a, 2) + "ими" : p(o, [ "люди" ]) ? f(a) + "ьми" : p(o, T) ? f(a) + "ями" : C(A) + "ами";
		}
		if ([ e.PREPOSITIONAL, e.LOCATIVE ].includes(i)) {
			return b() ? a + "х" : N() ? S(a, 2) + "ых" : w() ? S(a, 2) + "их" : p(o, T) ? f(a) + "ях" : C(A) + "ах";
		}
		if ([ e.GENITIVE, e.ACCUSATIVE ].includes(i)) {
			if (p(o, [ "овичи", "евичи" ])) {
				return f(a) + "ей";
			}
			if (o.endsWith("вны")) {
				return S(a, 2) + "ен";
			}
		}
		if (e.GENITIVE === i || e.ACCUSATIVE === i && s.isAnimate()) {
			if (b()) {
				return a + "х";
			}
			if (N()) {
				return S(a, 2) + "ых";
			}
			if (w()) {
				return S(a, 2) + "их";
			}
			const e = g(s), c = () => {
				const e = A.toLowerCase();
				if (p(e, [ "кн", "кл", "нк", "пк", "рк", "тк", "вк", "лк" ])) {
					const e = d(A);
					return f(A) + l("о", e) + e;
				}
				if (p(o, [ "дра" ])) {
					const e = I(a, 1);
					return S(a, 2) + l("е", e) + e;
				}
				if (p(e, [ "льц", "сьм", "деньг", "ьк", "йк" ])) {
					const e = d(A);
					return S(A, 2) + l("е", e) + e;
				}
				return p(e, [ "сл" ]) ? f(A) + "ел" : A;
			};
			if ([ 3, 0 ].includes(e)) {
				if (o.endsWith("и")) {
					return f(a) + "ей";
				}
				if ([ "гроздья" ].includes(o)) {
					return f(a) + "ев";
				}
			}
			const m = I(o, 2), L = [ "беготни", "болтовни", "вожжи", "возни", "доли", "лапши", "левши", "марли", "ноздри", "пени", "пятерни", "распри", "родни", "сакли", "ступни", "фигни", "чукчи" ];
			if (t.FEMININE !== h) {
				const e = [ "адреса", "поезда", "цеха", "снега", "бункера", "буфера", "берега", "вымпела", "голоса", "города", "директора", "договора", "доктора", "жемчуга", "инспектора", "инструктора", "колокола", "кондуктора", "короба", "корпуса", "крейсера", "кузова", "леса", "мастера", "номера", "острова", "отпуска", "сахара", "трактора", "тормоза", "холода", "цвета", "черепа", "шторма", "штуцера", "юнкера", "ястреба", "суда", "корм" ], n = e.concat([ "аланы", "беглецы", "близнецы", "бойцы", "бока", "борта", "борцы", "бруствера", "брюшки", "веера", "века", "венцы", "верха", "веса", "весы", "вечера", "вороха", "глупцы", "гонцы", "дворцы", "дельцы", "детдома", "детдомы", "дома", "жеребцы", "жильцы", "жрецы", "зубцы", "истцы", "катера", "концы", "корма", "кузнецы", "купола", "купцы", "мертвецы", "меха", "мудрецы", "облака", "образа", "образцы", "огурцы", "округа", "омута", "ордена", "ордера", "отцы", "очки", "певцы", "песцы", "пловцы", "подлецы", "продавцы", "птенцы", "резцы", "рубцы", "самцы", "свинцы", "сорта", "соуса", "спецы", "столбцы", "стрельцы", "творцы", "тельцы", "тенора", "терема", "тома", "тона", "торцы", "юнцы" ]), i = [ "аршины", "баклажаны", "буквы", "гольфы", "граммы", "гусары", "дела", "кадеты", "килограммы", "омы", "помидоры", "рентгены", "ботинки", "человеки", "чулки" ], u = [ "гектары", "рельсы" ], A = O.concat([ "бедняги", "бедолаги", "болгары", "бродяги", "будды", "веки", "вельможи", "верзилы", "владыки", "воеводы", "волосы", "вояки", "главы", "грузины", "задиры", "железы", "жилы", "зануды", "зеваки", "калеки", "коллеги", "крохи", "курицы", "куры", "ламы", "мужчины", "непоседы", "папы", "папаши", "таты", "падлы", "партизаны", "погоны", "предтечи", "работяги", "разы", "румыны", "самоубийцы", "убийцы", "сапоги", "сатаны", "сироты", "слуги", "солдаты", "старосты", "татары", "телеса", "хитрюги", "шляпы", "яблоки", "дядьки", "дяденьки", "зайки", "кроссовки", "малютки", "малолетки", "попки", "турки" ]), T = [ "братишки", "дружки", "мальчишки", "парнишки", "сынишки", "папочки", "дедушки", "дядюшки", "батюшки", "городишки", "домишки" ];
				if (h === t.COMMON && !p(o, L) && ![ "ж", "ш", "ч" ].includes(m) || A.includes(o) || "барин" === s.lower()) {
					return c();
				}
				if (n.includes(o)) {
					return f(a) + "ов";
				}
				if (i.includes(o)) {
					return [ c(), f(a) + "ов" ];
				}
				if (u.includes(o)) {
					return [ f(a) + "ов", c() ];
				}
				if (p(o, [ "жи", "ши", "чи", "ля", "ли", "чи", "ри", "ти", "ди", "борщи", "клещи", "товарищи", "плащи", "прыщи", "хрящи" ]) || s.lower().endsWith("ь") && !p(s.lower(), [ "зять", "деверь" ])) {
					return ("ь" === d(f(o)) ? S(a, 2) : f(a)) + "ей";
				}
				if (p(o, [ "братья", "брусья", "деревья", "донья", "звенья", "клинья", "клочья", "коленья", "колосья", "колья", "комья", "крылья", "листья", "лоскутья", "перья", "платья", "поводья", "прутья", "стулья", "сучья", "ульи", "шилья" ])) {
					return f(a) + "ев";
				}
				if (p(o, [ "зятья", "кумовья", "деверья", "края", "клеи", "холуи" ]) || [ r("фтз"), "чаи" ].includes(o)) {
					return f(a) + "ёв";
				}
				if (p(o, [ "ья", "ия" ])) {
					return t.MASCULINE === h ? S(a, 2) + "ей" : S(a, 2) + "ий";
				}
				if (o.endsWith("мена")) {
					return S(a, 3) + "ён";
				}
				if (s.lower().endsWith("яйцо")) {
					return l("яиц", f(a));
				}
				if (p(o, [ "а", "не", "ищи" ]) && !p(o, e)) {
					return c();
				}
				if (p(o, [ "ницы", "лицы", "пицы", "бицы" ])) {
					return f(a);
				}
				if (o.endsWith("цы") || o.endsWith("и") && E(I(o, 1))) {
					return f(a) + "ев";
				}
				if (p(o, [ "жки", "шки", "чки" ]) && (t.MASCULINE !== h || p(o, T)) && !s.lower().endsWith("ок")) {
					return S(a, 2) + "ек";
				}
				if (o.endsWith("ьи")) {
					return t.MASCULINE === h ? f(a) + "ёв" : S(a, 2) + "ей";
				}
				if (p(o, [ "ы", "и", "а" ])) {
					return f(a) + "ов";
				}
			}
			if (o.endsWith("йки")) {
				return S(a, 3) + "ек";
			}
			if (o.endsWith("ки")) {
				if ("ь" === m) {
					const e = d(f(a));
					return S(a, 3) + l("е", e) + e;
				}
				if ([ "ж", "ш", "ч" ].includes(m)) {
					return S(a, 2) + "ек";
				}
				if (u.includes(m)) {
					return S(a, 2) + "ок";
				}
			}
			if (L.includes(o)) {
				return f(a) + "ей";
			}
			if (p(o, [ "еи", "эи", "уи" ])) {
				return f(a) + "й";
			}
			if ("свечи" === o) {
				return [ f(a), f(a) + "ей" ];
			}
			if ("пригоршни" === o) {
				return [ f(a) + "ей", S(a, 2) + "ен" ];
			}
			if ("тихони" === o) {
				return [ S(a, 2) + "нь", f(a) + "ей" ];
			}
			if (p(o, [ "ьи", "ии" ])) {
				return n.sd.hasStressedEndingSingular(s, i).includes(!0) ? S(a, 2) + "ей" : S(a, 2) + "ий";
			}
			if (o.endsWith("ни") && u.includes(I(o, 2))) {
				return [ "барышни", "боярышни", "деревни" ].includes(o) ? S(a, 2) + "ень" : o.endsWith("кухни") ? S(a, 2) + "онь" : S(a, 2) + "ен";
			}
			if (A.toLowerCase().endsWith("ийк")) {
				return S(A, 2) + "ек";
			}
			if (A.length === o.length - 1 && p(o, T)) {
				if ([ "ь", "й" ].includes(I(A, 1).toLowerCase()) && !s.isAnimate()) {
					const e = d(A);
					return S(A, 2) + l("е", e) + e;
				}
				return A + "ь";
			}
			return c();
		}
		return a;
	}
	return Object.freeze(i);
});